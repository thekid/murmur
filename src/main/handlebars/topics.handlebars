{{#> layout}}
  {{#*inline "title"}}Topics{{/inline}}
  {{#*inline "content"}}
    <h1 title="{{lookup help request.uri.path}}">{{> title}}</h1>
    <div class="ui vertical segment">
      <div class="ui form">
        <div class="field">
          <div class="ui fluid multiple search selection dropdown">
            <input type="hidden" id="topic" name="topic">
            <i class="dropdown icon"></i>
            <div class="default text">Select Topics</div>
          </div>
        </div>
        <button id="button" class="ui tiny labeled primary icon button" type="submit" onclick="update()">
          <i class="hashtag icon"></i>
          Load
        </button>
      </div>
    </div>

    <!-- Feed generated by these groups -->
    <div class="ui vertical segment" id="content">
      <div class="ui stackable cards" id="feed">
      </div>
    </div>
  {{/inline}}
  {{#*inline "script"}}
    <script type="text/javascript">
      const following = {{{following}}};
      const results = {};
      let selected = {};

      function update() {
        const $button = document.getElementById('button');
        const $feed = document.getElementById('feed');
        const template = Handlebars.compile(`{{{source 'templates/messages'}}}`);

        // Update local storage, ignoring exceptions
        try {
          localStorage.setItem('selected.topics', JSON.stringify(selected));
        } catch (e) {
          console.log(e);
        }

        let todo = Object.keys(selected).length;
        if (0 === todo) {
          $feed.innerHTML = '';
          return ;
        }
        
        let completed = () => {
          todo--;
          if (todo > 0) return;

          let edges = [];
          let errors = [];
          for (const id in selected) {
            if (undefined === results[id]) {
              errors.push('Missing result for group #' + id);
            } else if (null === results[id].error) {
              edges = edges.concat(results[id].result.topic.feed.threads.edges);
            } else {
              errors.push('Error fetching topic #' + id + ': ' + results[id].error.message);
            }
          }

          edges.sort((a, b) => ((a.node.updatedAt === b.node.updatedAt) ? 0 : ((a.node.updatedAt > b.node.updatedAt) ? -1 : 1)));

          $feed.innerHTML = template({edges: edges, errors: errors, following: following});
          $button.classList.remove('loading');
          $('.excerpt').popup();
        }

        $button.classList.add('loading');
        for (const id in selected) {
          if (undefined === results[id] || null !== results[id].error) {
            fetch('/api/feed/topics/' + id + '/all?limit=5', {method: 'GET', credentials: 'same-origin'})
              .then(res => res.ok ? res.json() : (function() { throw new Error(res.status + ': ' + res.statusText); })())
              .then(result => { results[id] = {result: result, error: null}; completed(); })
              .catch(error => { results[id] = {result: null, error: error}; completed(); })
            ;
          } else {
            completed();
          }
        }
      }

      window.onload = function() {
        let stored = null;
        try {
          stored = localStorage.getItem('selected.topics');
        } catch (e) {
          console.log(e);
        }

        let values = [];
        if (null !== stored) {
          selected = JSON.parse(stored);
          for (const id in selected) {
            values.push({name: selected[id], value: id, selected: true});
          }
        }

        $('.search.ui.dropdown').dropdown({
          apiSettings : {url: '/api/autocomplete/topics?q={query}'},
          onAdd       : function(value, text, $choice) { selected[value]= text; },
          onRemove    : function(value, text, $choice) { delete selected[value]; },
          values      : values
        });

        if (values.length) update();
      };
    </script>
  {{/inline}}
{{/layout}}